

\documentclass[11pt,toc=sectionentrywithoutdots, 
headheight=44pt, headings=optiontoheadandtoc, hyperfootnotes=false, hypertexnames=false]{scrartcl}



%Packages
\usepackage{geometry}
\usepackage{float}
\usepackage{setspace}
\usepackage{wrapfig}
\usepackage{pdfpages}
\setstretch{1.5}



%%%%%%%%%%%%%%%%%% OLD GEOMETRTRY

%\geometry{
%a4paper, 
%left=30mm, 
%right=25mm, 
%top=25mm, 
%bottom=25mm, 
%headsep=5mm, 
%footnotesep=5mm,
%headheight=20mm,
%footskip=15mm,
%marginparwidth=15mm
%}



%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%% Connys Geometry
\geometry{
a4paper,
left=25mm,
right=25mm,
top=35mm,
headheight=35mm,
headsep=2.5em,
bottom=35mm,
footskip=2.5em,
footnotesep=1em,
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\usepackage{times}
\usepackage{verbatim}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage[headsepline]{scrlayer-scrpage}
\usepackage{blindtext}
\usepackage{footnotebackref}
\usepackage{nameref}

\usepackage[automake]{glossaries}
\usepackage[export]{adjustbox}
\usepackage{wrapfig,lipsum,booktabs}
\usepackage{placeins}
%\captionsetup[wraptable]{margin=x cm, width= y cm}
\usepackage{caption}
\usepackage{mathtools}
\usepackage{eurosym}

\newcommand\extendedref[1]{Siehe \ref{#1}}
\newcommand\fullref[1]{\extendedref{#1} auf Seite \pageref{#1}}



\setstretch{1.2}

\usepackage[
backend=biber,
style=authortitle,
citestyle=authoryear
]{biblatex}

\addbibresource{literatur.bib}

 %\usepackage{tikz,ifthen,xstring,calc,pgfkeys,pgfopts}
 %\usepackage{tikz-uml}
 %\usetikzlibrary{external}


\usepackage{hyperref}
\usepackage[printonlyused, withpage]{acronym}

%%%%%%%%%%%%%%%%%% Compile optimization - Kill for release!!!%%%%%%%%%%%%%%
% Kill draft in Dokumentclass!!!
%\pdfcompresslevel=0
%\pdfobjcompresslevel=0
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hypersetup{
    colorlinks=true,
    linktoc=page,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    citecolor=blue
}



%%%%%%%%%%%%%% Set line Spacing for Abbreviation %%%%%%%%%%%%%%%%%%
%\renewenvironment{description}
%{\list{}{\labelwidth0pt\itemindent-\leftmargin
%    \parsep0pt\itemsep0pt\let\makelabel\descriptionlabel}}
%               {\endlist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usetikzlibrary{external}
%\tikzexternalize %



%Function for getting sectionName---------------------------------------------------

\newcounter{secautolabel}
\AddtoDoHook{heading/endgroup}{\setautolabel}
\newcommand*{\setautolabel}[1]{%
  \stepcounter{secautolabel}%
  \label{sec:autolabel:\thesecautolabel}%
  \expandafter\xdef\csname #1title\endcsname{%
    \noexpand\nameref*{sec:autolabel:\thesecautolabel}%
  }%
}

\newcommand\sectionRefs{%
	\sectiontitle  
}
%\interfootnotelinepenalty=10000

%Function for getting sectionName----------------------------------------------------



%Images path
\graphicspath{{./src/images/}}

%Document meta data
\geometry{bottom=25mm, right=25mm, left=25mm, top=35mm}

%Set page numbering font
\renewcommand{\headfont}{\normalfont}

\makeglossaries

\newglossaryentry{Query}
{
	name=Query,
	description={Datenbankanweisung, welche an einen Datenbankserver 		verschickt wird und dazu dient, Daten abzufragen, zu erstellen, zu verändern oder zu löschen}
}
\newglossaryentry{Assembly}
{
	name=Assembly,
	description={Logische Organisationseinheit in .NET, welche einen Baustein einer größeren Anwendung darstellt. Auch \glqq Komponente\grqq{} oder \glqq Modul\grqq{} genannt}
}
\newglossaryentry{Persistenz}
{
	name=Persistenz,
	description={Die theoretische Möglichkeit eines Objekts unendlich und unabhängig von der Software, in der es erzeugt wurde, zu existieren. In der Praxis kann keine hundertprozentige Persistenz gewährleistet werden}
}
\newglossaryentry{Customer Obsession}
{
	name=Customer Obsession,
	description={Wirtschaftsphilosophie, die den Kunden als Maßstab für alle Überlegungen des ökonomischen Denken und Handels emporhebt. Gemäß dieses Ansatzes gibt es keine den Wünschen des Kunden übergeordneten Maxime}
}
\newglossaryentry{Kanban}
{
	name=Kanban,
	description={Prinzip für das Abarbeiten von Aufgaben im Team, bei dem alle anfallenden Aufgaben mit einer Karte visualisiert werden, die in Säulen von festgelegter maximaler Stückzahl abgelegt sind. Steigt eine Aufgabe im Bearbeitungsstadium auf, wird sie von links nach rechts \glqq gepullt\grqq{}. Die rechteste Säule trägt immer den Namen \glqq Done\grqq}
}
\newglossaryentry{Product Owner}
{
	name=Product Owner,
	description={\glqq Der:die Product Owner:in ist ergebnisverantwortlich für die Maximierung des Wertes des Produkts, der
sich aus der Arbeit des Scrum Teams ergibt. Wie dies geschieht, kann je nach Organisation, Scrum Team
und Individuum sehr unterschiedlich sein\grqq\footnote{Entnommen aus \cite{SchwaberSutherland2020}}}
}
\newglossaryentry{Pain Driven Development}
{
	name=Pain Driven Development,
	description={\glqq Pain Driven Development, or PDD, is the practice of writing software in such a way that you only \glq fix\grq{} problems when they are causing pain, rather than trying to preempt every possible issue\grqq\footnote{Entnommen aus \cite{Smith2017}}}
}
\newglossaryentry{Refaktorierung}
{
	name=Refaktorierung,
	description={\glqq Code-Refactoring ist der Prozess der Umstrukturierung bestehenden Quellcodes ohne dessen externes Verhalten zu ändern. Refactoring verbessert keine funktionalen Attribute der Software. Die Vorteile von Refactoring umfassen verbesserte Lesbarkeit des Codes und reduzierte Komplexität\grqq\footnote{Entnommen aus \cite{Kranz2021}}}
}
\newglossaryentry{IntelliSense}
{
	name=IntelliSense,
	description={Von Microsoft entwickeltes Werkzeug für die integrierten Entwicklungsumgebungen Visual Studio und Visual Studio Code, welches der Programmiererin während beim Entwickeln eine Übersicht darüber gibt, welche Variablen, Klassen und Methoden an der gerade zu bearbeiteten Stelle im Code zur Verfügung stehen}
}
\newglossaryentry{Legacy Code}
{
	name=Legacy Code,
	description={Code, der von mittlerweile nicht mehr kontaktierbaren Entwicklern \glqq geerbt\grqq{} wurde, nicht mehr in allen Aspekten dem aktuellen Stand der Technik entspricht und darüber hinaus nicht umfassend dokumentiert ist}
}
\newglossaryentry{Open Source}
{
	name=Open Source,
	description={Software, die von den Entwickler öffentlich zur Verfügung gestellt wird, ohne dass dabei Kosten für Interessenten anfallen. Die entsprechende Software kann für jeden erdenklichen Zweck verwendet, also auch erweitert oder modifiziert werden. Ebenso kann Open-Source-Software für kommerzielle Zwecke verwendet werden}
}
\newglossaryentry{Breakpoint}
{
	name=Breakpoint,
	description={Markierung am Rand der Zeile im Programmcode, an der die Ausführung des Programms an eben dieser Stelle angehalten wird. Nach dem Anhalten kann im Code-Editor bzw. der integrierten Entwicklungsumgebung der aktuelle Status von Variablen abgefragt werden und bei Bedarf Zeile für Zeile weiter ausgeführt werden}
}
\newglossaryentry{Single Responsibility Principle}
{
	name=Single Responsibility Principle,
	description={Das erste Prinzip aus den fünf vom Softwareentwickler Robert C. Martin formulierten \glq SOLID\grq{}-Prinzipien, welches besagt, das ein Modul nur einen einzigen Grund haben sollte, sich zu ändern. Beispielsweise kann sich ein Modul entweder in Hinblick auf die GUI ändern oder in Hinblick auf die Datenbankkommunikation, aber niemals mal das eine, mal das andere}
}
\newglossaryentry{Abstrakte Klasse}
{
	name=Abstrakte Klasse,
	description={Klasse aus der kein Objekt instanziert werden kann. Abstrakte Klassen dienen als Blaupause für weitere Klassen, welche von ihr erben}
}
\newglossaryentry{SqlCommand}
{
	name=SqlCommand,
	description={Nicht mit \glqq Query\grqq{} zu verwechseln. Es handelt sich um eine Klasse aus .NET. Diese speichert Parameter, die für Tabellenspalten stehen, die dazugehörigen Datentypen und eine schematische Query mit Platzhaltern für Werte, die in den Spalten gespeichert werden sollen}
}
\newglossaryentry{Boolean}
{
	name=Boolean,
	description={Standard-Datentyp aus allen bekannten Programmiersprachen, der entweder den Wert \glqq wahr\grqq{} oder \glqq falsch\grqq{} annehmen kann}
}
\newglossaryentry{Pull Request}
{
name=Pull Request,
description={
\glqq A pull request is a method of submitting contributions to an open development project. It is often the preferred way of submitting contributions to a project using a distributed version control system (DVCS) such as Git\grqq{}\footnote{Entnommen aus \cite{Johnson2013}}}
}
\newglossaryentry{Datenbank Management System}
{
	name=Datenbank Management System,
	description={Komplexe Applikation mit ausführlicher graphischer Benutzeroberfläche, das für die Arbeit mit Datenbanken und Datenbankanfragen konzipiert ist. Obwohl diese Programme keine Voraussetzung dafür sind, mit Datenbanken zu arbeiten (denn erfahrene Informatikerinnen können dies auch manuell), arbeitet nahezu jedes Unternehmen mit einem solchen System}
}
\newglossaryentry{List}
{
	name=List,
	description={.NET-Klasse, die klassische Arrays aus C\# ersetzt. Lists werden zwar wie Arrays eingesetzt, sind aber deutlich dynamischer. So ist deren Datentyp statisch, jedoch nicht deren Größe. D.h. ihre Größe nimmt zu, wenn ein Element hinzukommt und nimmt ab, wenn ein Element gelöscht wird. Zudem besitzen sie mehrere Sortier- und Filterfunktionen}
}
\newglossaryentry{Connection String}
{
	name=Connection String,
	description={\glqq Ein Connection String beschreibt den Standort einer Datenbank (Rechnername oder IP-Adresse ggf. Port oder Dateisystempfad) und den Zugangsweg (Protokoll, Authentifizierung) sowie Verbindungseinstellungen zu dieser Datenbank\grqq{}\footnote{Entnommen aus \cite{Schwichtenberg2021}}}
}
\newglossaryentry{Access-Modifier}
{
	name=Access-Modifier,
	description={Schlüsselwort aus der Objektorientierten Programmierung, das Sichtbarkeit von Daten außerhalb der eigenen Klasse regelt. Die wichtigsten beiden sind \glqq private\grqq{} und \glqq public \grqq{}}
}\newglossaryentry{Komposition}
{
	name=Komposition,
	description={Die Komposition zeigt eine notwendige "ist-Teil-von" Beziehung an. Das Teil kann also nicht ohne das Ganze existieren\footnote{Entnommen aus \cite{Thoma2012}}}
}
\newglossaryentry{Dynamisch}
{
	name=Dynamisch,
	description={Von dynamisch geschriebenen Programmiersprachen spricht man, wenn der Datentyp erst in der Runtime durch einen Interpreter entschieden wird und sich jederzeit wieder ändern kann. In einer statisch geschriebene Programmiersprache hingegen, ist er Datentyp unveränderlich und kann sich in der Runtime nicht mehr ändern.}
}
\newglossaryentry{Dictionary}
{
	name=Dictionary,
	description={\glqq Ein Dictionary ist mit einem Wörterburch zu vergleichen. In einem Wörterbuch finden sie unter einem Schlüsselbegriff die zugeordnete Information. So steht etwa in einem englisch-deutschen Wörterbuch unter dem Eintrag \textit{house} der zugeordnete deutsche Begriff \textit{Haus}\grqq{} \footnote{Entnommen aus \cite{Theis2014} S. 120}}
}




\begin{document}
\includepdf{erklaerung.pdf}


\setlength{\parindent}{0em} % Einrückung
\setlength{\parskip}{0em} % Abstand zwischen Absätzen

\pagenumbering{Roman}
\thispagestyle{empty}

\cfoot[]{}
%\ofoot{Seite \thepage\:von \pageref{LastPage}}
\ofoot{\thepage}
\ifoot{© Frank Loleit}
%\ohead{\includegraphics[scale=0.125]{argusLogo}}
\ohead{\includegraphics[scale=0.15]{argusLogo}}



\ihead
{%	
	\begin{small}
	
	
		MODUL FÜR GEKAPSELTE DATENBANKKOMMUNIKATION\newline EINER DESKTOPANWENDUNG%		
		\newline\
		\textit\sectionRefs
	\end{small}%
}
%IHK-Logo
\begin{figure}[h]
\includegraphics[scale=0.25]{ihkLogo}
\centering
\end{figure}
\begin{center}
\begin{Large}

Abschlussprüfung Winter 2021
\linebreak

Fachinformatiker (Anwendungsentwicklung)\linebreak
Dokumentation der betrieblichen Projektarbeit
\linebreak\linebreak
\end{Large}


\begin{LARGE}
\begin{bfseries}
	Entwicklung eines Moduls in einer Desktopanwendung zur Umstellung von direkten Datenbankzugriffen zu einer gekapselten Datenbankkommunikation mit optionaler Simulationsmöglichkeit.
\linebreak\linebreak
\end{bfseries}
\end{LARGE}

\begin{Large}
%Backend-Applikation zur algorithmusbasierten 
%Erfassung von\linebreak Meldungen in sozialen Netzwerken
%\linebreak

Abgabetermin: 09.12.2021
\linebreak\linebreak
\begin{bfseries}
Auszubildender:\linebreak
\end{bfseries}
Frank Loleit\linebreak
Wildenbruchstr. 43\linebreak
12435 Berlin\linebreak

\begin{figure}[h]
\includegraphics[scale=0.25]{argusLogo}
\centering
\end{figure}



\begin{bfseries}
Ausbildungsbetrieb:\linebreak
\end{bfseries}
ARGUS DATA INSIGHTS® Deutschland GmbH\linebreak
Gneisenaustr. 66\linebreak
10961 Berlin


\end{Large}


\end{center}
\newpage
\setcounter{page}{1}
\pagenumbering{Roman}


\tableofcontents


\setcounter{secnumdepth}{0}

\newpage

\phantomsection
\addcontentsline{toc}{section}{Abbildungsverzeichnis}
\listoffigures




%\newpage

\phantomsection
\addcontentsline{toc}{section}{Tabellenverzeichnis}
\listoftables
%\newpage

%\section{Listings}
%\blindtext\blindtext\blindtext
%\newpage

\section{Abkürzungsverzeichnis}


\begin{acronym}[xxxxxxx]

\acro{ADI}{Argus Data Insights Deutschland GmbH}
\acro{CRUD}{Create, Read, Update, Delete}
\acro{GUI}{Graphical User Interface}
\acro{XAML}{Extensible Application Markup Language}
\acro{DRY}{Don't Repeat Yourself}
\acro{SQL} {Structured Query Language}
\acro{SSMS} {SQL Server Management Studio}
\acro{PO} {Product Owner}
\acro{UML} {Unified Modeling Language}
\acro{IDE} {Integrated Development Environment}

\end{acronym}
\clearpage

\phantomsection
\addcontentsline{toc}{section}{Glossar}
\printglossary[nonumberlist]
\newpage


\setcounter{secnumdepth}{1}
\pagenumbering{arabic}
\setcounter{secnumdepth}{4}
\ofoot{Seite\:\thepage}%\:von \pageref*{myLastPage}%}

\section{Einleitung}
In diesem Projekt wird das Ziel verfolgt, die Datenbankkommunikation einer Desktopanwendung zu vereinheitlichen und die Arbeit der Entwickler von der Arbeit der Nutzer abzugrenzen. Obgleich es sich bei dem entwickelten Modul um ein Werkzeug handelt, das nur von Entwicklern geöffnet und verwendet werden kann, steht der Kunde im Vordergrund aller Bemühungen. Denn sowohl das Auffinden und Lösen von Programmfehlern, wie auch das Implementieren von neuen Komponenten kann durch die Vereinheitlichung und Separierung der Datenbankoperationen deutlich effizienter werden. Der Kunde erhält dadurch nicht nur ein tendenziell stabileres System, sondern kann auch damit rechnen, dass neue gewünschte Funktionalitäten schneller umgesetzt werden. In diesem Sinne steht bei allen Bemühumgen dieses Projektes stets die \gls{Customer Obsession} im Vordergrund.

\subsection{Projektbeschreibung}
Ausgangspunkt der Arbeit ist die Desktopapplikation \glqq Arche\grqq{}, entwickelt im .NET-Framework\footnote{\cite{Microsoft2020}} 3.5 mit WinForms-\acs{GUI}. Das Debugging gestaltet sich teils als recht aufwändig, da alle Funktionen umgangen werden müssen, die Kundendaten generieren, verändern oder löschen. Grund dafür ist das Fehlen von Mechanismen, durch die sich Datenbankoperationen, die von Kunden und Entwicklern vorgenommen werden, jeweils voneinander abgrenzen lassen.\newline Auch das Implementieren von neuen datenbanksensiblen Features gestaltet sich als umständlich, da es kein einheitliches Prinzip für die Datenbankkommunikation gibt. Viel mehr hat jeder einzelne Workflow jeweils eine eigene Klasse für die Datenbankkommunikation, die sich inhaltlich aber kaum unterscheiden, sondern im Wesentlichen voneinander kopiert wurden und das \acs{DRY}-Prinzip wenig Berücksichtigung findet. Daher soll ein Modul entwickelt werden, dass die Kommunikation mit der Datenbank kapselt.\newline\newline Zunächst soll es möglich sein, dass eine \gls{Query}, die ein beliebiger Workflow an den Datenbankserver übergibt, zurückgehalten werden kann und somit nicht Gefahr zu laufen, unerwünschte Änderungen an Datenbankeinträgen vorzunehmen. Dabei soll in einer für Entwickler bestimmten GUI die entsprechende Query mit sinnvoller Hervorhebung entsprechender Keywords erfolgen. Zudem soll der Entwickler frei entscheiden können, ob die Query verarbeitet, zurückgehalten oder in ein \acs{SQL}-Management-System übertragen werden soll. Im Anschluss soll die uneinheitliche Datenbankkommuniktation durch eine globale Logik mit Hilfe von Datenbankmodellen ersetzt werden. Aus diesen Modellen soll schlussendlich ein einheitliches Verfahren abgeleitet werden können, das die Datenbankanbindung auf ein einziges \gls{Assembly} des Projektes konzentriert und somit eine langfristige Arbeitserleichterung schafft.

\subsection{Projektziel}
Nach Abschluss des Projektes muss es möglich sein, in Arche Insert-, Update- und Delete-Funktionen auszulösen, ohne dabei Kundendaten zu beeinträchtigen. Ist das zu entwickelnde Modul aktiv und es wird in der GUI von Arche ein Speichern- oder Löschen-Button geklickt, soll Arche angehalten und stattdessen ein Fenster öffnen, das nur für Entwickler bestimmt ist. Dieses gibt nun die Query aus, welche an den Datenbankserver geschickt worden wäre. Die Möglichkeit, die Query mit einem Klick umgehend nach \acs{SSMS} zu versenden muss ebenfalls gegeben sein, wie die Funktion, frei entscheiden zu können, ob die Query von Arche ausgeführt wird oder nicht. Die Entwickler müssen die Möglichkeit erhalten die Datenbank lokal zu simulieren und die entsprechenden Queries lokal auszuführen. Zudem muss ein einheitliches auf Datenbankmodellen basierendes Prinzip implementiert werden, über welches jedwede Insert-, Update- und Delete-Query mit entsprechenden Parametern generiert werden kann.%keine Unstimmigkeiten mit dem 
%Webinterface auftreten. Die \acs{ADI} ist daher bemüht weitere Schritte %einzuleiten. Man hat sich entschieden \acs{XAML} zu verwenden. Auch %Mathematisch ist dies wichtig\footnote{vgl. \cite{GeraldTeschl2008}}.

\subsection{Projektumfeld}
Argus Data Insights (im Folgenden \glqq Argus\grqq{} genannt) ist darauf spezialisiert, Print- , Video- und Onlinemedien - insbesondere Zeitungen, Fernsehen und soziale Netzwerke - für angefragte Zeiträume und Themen zu durchsuchen und dem Kunden skalierbare Dossiers mit Informationen zur eigenen Person, Firma oder Einrichtung zu geben. Die Kunden erlangen auf diese Weise einen detaillierten Einblick darüber, wie viel Aufmerksamkeit der Kunde in den Medien allgemein erhält, welche Themen mit dem Kunden assoziiert werden und und die Berichterstattung tendenziell positiv, negativ oder neutral ausfällt. Die Redaktionssoftware Arche wird sowohl zum Digitalisieren, Annotieren, Aufbereiten und Versenden der für den Kunden angefertigten Dossiers verwendet.\newline Dabei werden vor allem Print- und Onlineinhalte unterschieden. Die verschiedenen Medieninhalte werden in Fileservern abgelegt, deren Pfade sowie zahlreiche Medienparameter in Datenbanktabellen gespeichert. Darüber hinaus gibt es eine umfangreiche Kundendatenbank. Datenbankzugriffe erfolgen nicht einheitlich, sondern von verschiedenen \gls{Persistenz}-Klassen aus, deren interne Logik von jeweils der zuletzt angelegten Persistenzklasse kopiert ist (nicht vererbt).

\subsection{Projektbegründung}
Die Gründe für das Projekt liegen in der erschwerten Wartung der Software, sowie dem erhöhten Aufwand, neue datenbanksensible Komponenten hinzuzufügen. Muss ein Ticket\footnote{Bei Argus wird das \gls{Kanban}-Board \href{https://www.atlassian.com/software/jira}{Atlassian Jira} verwendet.} bearbeitet werden, bei dem ein Problem mit Query und/oder Datenbank vermutet wird, müssen beim Debugging sehr früh Breakpoints gesetzt werden, um nicht Gefahr zu laufen, Kundendaten irreversibel zu verändern. Es fehlt die Möglichkeit, global die Ausführung von Datenbankprozessen zurückzuhalten. Darüber hinaus ist es äußerst kompliziert, die entsprechende Query zu erhalten, welche es für das jeweilige Ticket zu analysieren gilt. Daran anschließend ist kein einheitlicher Prozess vorhanden, der die Kommunikation von .NET und MSSQL steuert. Um sowohl Wartbarkeit, als auch einfache Erweiterbarkeit zu gewährleisten, ist dieses Projekt in Absprache mit den \gls{Product Owner}n entstanden.

\subsection{Projektabgrenzung}
Was die technische Abgrenzung anbelangt, ist durch die komponentenorientierte Arbeitsweise in .NET das zu entwickelnde Modul gut von bereits fertigen Projekten innerhalb der Kernapplikation getrennt. Konkret bedeutet das, dass das neue Modul \glqq DBEncapsulation\grqq{} und dessen Testmodul \glqq DBEncapsulationTests\grqq{}\footnote{\extendedref{fig:Assemblies}} per se isoliert und interagieren nur dann mit der Hauptapplikation Arche, wenn eine Referenz zu einem anderen Modul hergestellt wird. Wird eine Variable oder Methode aus DBEncapsulation als öffentlich deklariert, ist sie dennoch vorerst in keinem der anderen Module verfügbar und trägt nicht zur Überlastung der \gls{IntelliSense} bei. Soll das Modul aus einem bereits entwickelten Modul verfügbar sein, muss dessen Projektdatei zunächst eine Referenz auf DBEncapsulation hinzugefügt werden. Im nächsten Schritt kann denjenigen Klassen, welche datenbankrelevante Prozesse implementieren ein \glqq using\grqq{}-Statement hinzugefügt werden. Erst unter diesen Voraussetzungen, sind in der entsprechenden Klasse Daten verfügbar, die als öffentlich deklariert sind.\newline Bezüglich der inhaltlichen Abgrenzung ist festzuhalten, dass aufgrund der hohen Vielfalt an Datenbankoperationen zunächst Insert- Update- und Delete im Vordergrund stehen werden. Da Select-Operationen keine Beeinträchtigungen von Kundendaten zur Folge haben können, wird für diese Fälle vor allem im Vordergrund steht den Entwicklern ein korrektes Feedback darüber zu geben, welche Tabellen und Spalten nach welcher Abfragelogik an die Datenbank übermittelt wurden. Da Select-Operationen stark heterogen sind, wird hier kein einheitlicher Prozess für angestrebt. Jedoch soll es für die Fälle Update, Insert und Delete grundsätzlich nicht mehr nötig sein, neue Logiken für neue Module zu entwerfen und lediglich durch Referenzierung auf DBEncapsulation entsprechende Funktionalitäten bereit gestellt werden.

\section{Projektplanung}
Für die Planung ist wesentlich, dass das Tagesgeschäft der Entwicklerinnen bei Argus nicht unterbrochen wird, sondern parallel zum hier dokumentierten Projekt mit allen zeitlichen und finanziellen Aufwendungen weiterläuft. Das heißt, bei der Projektplanung ist ein sinnvolles Verhältnis von Recherche, selbstständigem Kodieren und eigenverantwortlichen Entscheidungen einerseits, sowie zielgerichtete Unterstützung durch Ausbilder und Kolleginnen andererseits. Um den stetigen Austausch zu gewährleisten, wird der Fortschritt dieses Projektes im täglichen Meeting mit Vorgesetzten und Teammitgliedern geteilt. Zudem werden regelmäßige sowie spontane 1:1-Gespräche mit dem Ausbilder durchgeführt.

\subsection{Projektphasen}
Das Projekt wurde in einem Zeitraum von 70 Stunden umgesetzt. Dabei wurde die gesamte Stundenanzahl wie folgt aufgeteilt\footnote{\extendedref{sec:Detaillierte Zeitplanung}}:
\begin{comment}
\begin{table}[ht]
	%\begin{center}
		\begin{tabular}{l|r}
			\hline
			\textbf{Projektphase} 		& \textbf{Geplante Zeit} \\
			\hline

			Analysephase 				& 7 h	 		\\
			Entwurfsphase				& 11 h	 		\\
			Implementierungsphase 		& 40 h	 		\\
			Abnahme und Einführung		& 2 h 			\\
			Erstellen der Dokumentation & 10 h 			\\
			\hline
			\textbf{Gesamt}	 			& \textbf{70 h}	\\
			
			\hline
		\end{tabular}
		%\caption{Zeitplanung}
	%\end{center}
\end{table}%
\end{comment}

\begin{wraptable}{l}{0pt}
\begin{tabular}{lr}

\textbf{Projektphase} 		& \textbf{Geplante Zeit} \\
%\hline
Analysephase 				& 7 h	 		\\
Entwurfsphase				& 11 h	 		\\
Implementierungsphase 		& 40 h	 		\\
Abnahme und Einführung		& 2 h 			\\
Erstellen der Dokumentation & 10 h 			\\
%\hline
	\textbf{Gesamt}	 			& \textbf{70 h}	\\
\end{tabular}

\end{wraptable}
Den Einstieg in das Projekts betreffend ist zu erwähnen, dass es sich bei dem Projekt Arche um \gls{Legacy Code} handelt, dessen Funktionsweise nur begrenzt objektorientiert aufgebaut ist. Sowohl bei Analyse, Entwurf und Implementierung ist daher immer das Nachvollziehen des Codes durch Recherche, Debugging und Rücksprache mit erfahrenen Mitarbeitern entscheidend.
\clearpage
\subsection{Ressourcenplanung}
%Die notwendigen Ressourcen für das Projekt sind sowohl monetärer als auch nicht-monetärer Art. Nicht monetäre Ressourcen umfassen vor allem zeitliche Aufwendungen von Ausbilder und Kolleginnen, %sowie Recherche
Bei der Planung der Ressourcen\footnote{\extendedref{sec:Ressourcenplan}} kann zwischen Hardware- und Softwareressourcen unterschieden werden. Bei der Auswahl wurde darauf geachtet, keine neuen Kosten zu generieren. Bei der Hardware kamen daher die von Unternehmen und Bildungseinrichtung bereitgestellten Computer zum Einsatz. Die eingesetzte Software ist entweder \gls{Open Source} oder es existieren bereits entsprechende Lizenzen bei Argus. Das heißt, es wurden keine Ressourcen angeschafft, die vor Beginn des Projektes nicht vorhanden gewesen wären. Bezüglich des Personals ist ebenfalls festzuhalten, dass sowohl Ausbilder als auch Kolleginnen täglich kontaktierbar oder vor Ort waren. Code-Reviews und Einarbeitungen konnten in den Arbeitsalltag so integriert werden, dass keine neuen personellen Ressourcen notwendig wurden.

\subsection{Entwicklungsprozess}
Bevor der Entwicklungsprozess starten konnte, war es nötig, den Quellcode von Arche in ausgewählten Stellen zu debuggen. Dabei ging es nicht darum, Fehler zu beheben, sondern Schritt für Schritt den Code nachzuvollziehen. Dies war aus zweierlei Hinsicht sinnvoll: Zunächst hatte ich so die Möglichkeit, Wissen über C\# und die Arbeit mit Visual Studio\footnote{In die Auswahl geeigneter \acs{IDE}s kamen Visual Studio, JetBrains Rider und Monodevelop. Nähere Informationen \extendedref{sec:Auswahl der Integrierten Entwicklungsumgebung}} zu sammeln und andererseits die zu bearbeitende Software Arche besser kennenzulernen. Hier wurde zunächst so vorgegangen, dass in der GUI von Arche der Text von Buttons und Labels in die Suchmaske des Visual-Studio-Explorers eingegeben wurden. Auf diese Weise konnten diejenigen Komponenten und Klassen identifiziert werden, welche für das Frontend an der entsprechenden Stelle genutzt wurden. Anschließend wurde weit oben im Code ein \gls{Breakpoint} gesetzt und dann im Debug-Modus einen Button aus der GUI geklickt.\newline\newline Da es bei diesem Projekt um Datenbankprozesse geht, wurden vor allem Buttons mit der Aufschrift \glqq Speichern\grqq{}, \glqq Aktualisieren\grqq{} oder \glqq Hinzufügen\grqq{} gewählt. Nun wurde in Absprache mit erfahrenen Kollegen der Code immer soweit weiter ausgeführt, bis die datenbankrelevante Funktion erreicht wurde, die Ausgangspunkt für dieses Projekt sein soll. Auf diese Weise konnte nicht nur die Funktionsweise von Arche besser verstanden, sondern auch jene Stellen bestimmt werden, an denen die hier zu entwickelnde Komponente andocken soll. An dieser Stelle muss erwähnt werden, dass es vor allem zu Beginn des Projektes nicht immer gelungen ist, Veränderungen an Datenbankeinträgen rechtzeitig zu unterbinden. Ungewollte Veränderungen von Daten kamen vor allem dadurch zustande, dass nicht immer klar war, ob eine Funktion die Beeinflussung von Daten vorbereitet oder bereits ausführt. Gelegentlich mussten daher einzelne Zeilen in der Datenbank manuell wieder eingefügt oder Rücksprache mit den Kunden gehalten werden. Diese Erfahrung war prägend für die generelle Herangehensweise an das Projekt, welche als \gls{Pain Driven Development} bezeichnet werden kann.

\section{Analysephase}
Hier macht es Sinn in eine technische, sowie eine wirtschaftliche Analyse einzuteilen. In technischer Hinsicht wurde bereits angemerkt, dass das Verständnis des Codes nicht über Dokumentationen, sondern über das Debugging und das Gespräch mit Kollegen funktioniert. Häufig viel dabei auf, dass Funktionen in Arche bei niedriger Schriftgröße deutlich über eine Bildschirmseite hinausreichen können und verschiedene Softwarebereiche wie die Logik der GUI nur schwach von der Datenverwaltung, zu der auch die Datenbanklogik gehört, getrennt wurden\footnote{\extendedref{fig:Vermischung verschiedener Aufgabenbereiche}}. Da auch generell wenig Signaturen und keine Kommentare im Code vorhanden sind, bestand die Aufgabe darin, zunächst zu mutmaßen, welche Teile des Codes mit dem Speichern von Daten zusammenhängen könnten und welche jedwede anderen Funktionen erfüllen, die mit diesem Projekt nicht zusammenhängen.\newline Was die wirtschaftliche Analyse betrifft, ist nicht zuletzt der Zeitaufwand zu beachten, der notwendig wird, wenn wie im vorliegenden Fall das \gls{Single Responsibility Principle} nicht eingehalten wird.

\subsection{IST-Zustand}
Die Datenbankkommunikation von Arche ist so organisiert, dass verschiedene Medienklassen (z.B. Printmedien, Onlinemedien, Socialmedia-Posts usw.) jeweils eine Persistence-Klasse zur Verfügung haben. Benannt sind diese ungefähr nach Mediumname, z.B. \glqq PrintmedienTreffer.cs\grqq{} und \glqq PrintmedienTrefferPersistence.cs\grqq{}. Erstere enthält diverse Variablen und Funktionen, die mit dem entsprechenden Medium zusammenhängen\footnote{\extendedref{fig:PrintmedienTreffer.cs}}. Es gibt zwar auch hier keine Dokumentation, jedoch finden sich hier und da Kommentare der Entwicklerinnen, die Aufschluss über die entsprechende Geschäftslogik geben können. Es muss jedoch davon ausgegangen werden, dann nicht alle Variablen noch immer benötigt werden und womöglich datenbankrelevante und nicht datenbankrelevante Variablen vermischt sind. Die \gls{Abstrakte Klasse} \glqq AbstractTreffer\grqq{}\footnote{\extendedref{fig:AbstractTreffer.cs}} wiederum bildet die Basis für alle Medienklassen und enthält verschiedene Parameter, wie z.B mehrere Identifikationsnummern.\newline Was die boolischen Werte anbelangt, ist zum Verständnis zu erwähnen, dass in Arche Benennungen wir \glqq deleted\grqq{} oder \glqq loaded\grqq{} nicht den aktuellen Zustand eines Objektes beschreiben, sondern ausdrücken sollen, dass ein Objekt geladen oder gelöscht werden soll. Würde man also eine Neubenennung dieser boolischen Werte anstreben, wäre eine Formulierung wie \glqq toBeDeleted/toBeLoaded\grqq{} sinnvoll. Für das vorliegende Projekt steht jedoch zunächst die \gls{Refaktorierung} der Datenbanklogik, weniger der äußeren Form, im Vordergrund.\newline\newline Nutzt man in der Klasse \glqq AbstractTreffer\grqq{} die IntelliSense-Funktion für die Referenzabfrage der Funktion \glqq abstract int savePersistent()\grqq{}, werden 799 Implementierung in zahlreichen Klassen ausgegeben. Es ist also davon auszugehen, dass diese Funktion eine zentrale Rolle für das Ablegen von Daten in der Datenbank spielt. Ebenso wird hier der Arbeitsaufwand deutlich: Da die Funktion abstrakt ist, wird nur die Signatur übergeben. Für jede Klasse, die Daten mithilfe dieser Funktion abspeichern möchte, muss eine eigene Implementierung geschrieben werden. Dies ist zwar sicherlich dem Umstand geschuldet, für unterschiedliche Medien unterschiedliche Speichermechanismen zu benötigen, jedoch wird ist auch klar, dass Arbeitsaufwand zur Weiterentwicklung der Software unverhältnismäßig hoch ist. Obgleich Argus anstrebt, langfristig auf modernere Lösungen wie ASP.NET\footnote{\href{https://dotnet.microsoft.com/apps/aspnet}{https://dotnet.microsoft.com/apps/aspnet}} oder Angular\footnote{\href{https://angular.io/}{https://angular.io/}} zu setzen, ist das Unternehmen in der Situation, an jedem Wochentag Mediendossiers an Kunden ausliefern zu müssen. Der IST-Zustand der Entwicklung von datenbankrelevanten Komponenten kann also am treffendsten mit zu hoher finanzieller und zeitlicher Belastung beschrieben werden.

\subsection{Wirtschaftlichkeitsanalyse}
%Aus den obigen Erkenntnissen müssen nun also folgende Fragen abgeleitet werden: \textit{Wie lange dauert es durchschnittlich der Anwendung eine neue Persistence-Klasse hinzuzufügen? Wie viel %Kosten fallen bei der Entwicklung einer solchen Klasse an? Wie viel Zeit und Kosten können durch das Einführen einer gekapselten Datenbankkommunikation gespart werden?} Um dabei einen %realistischen Einblick in die Kostenstruktur geben zu können, ist
Um das vorliegende Projekt als wirtschaftlich betrachten zu können, muss also eine konkrete Reduzierung der oben genannten Zeit und Kosten erreicht werden. Zentrale Fragen dabei sind: \textit{Wie lange dauert es durchschnittlich der Anwendung eine neue Persistence-Klasse hinzuzufügen? Wie viel Kosten fallen bei der Entwicklung einer solchen Klasse an? Wie viel Zeit und Kosten können durch das Einführen einer gekapselten Datenbankkommunikation gespart werden?}\newline Hier ergibt sich die Schwierigkeit, dass unterschiedliche Persistence-Klassen natürlich auch unterschiedlich viel Zeit für die Entwicklung und somit unterschiedlich viel Entwicklungskosten mit sich bringen. Dennoch wird hier so akkurat wie möglich versuchst werden, Entlastungen für das Unternehmen mit konkreten Zeit- und Investitionseinheiten anzugeben, um einen Überblick über die Wirtschaftlichkeit des Projektes zu schaffen.


%\subsubsection{Beschaffung der Ausgangsdaten}
%\blindtext\

%\subsubsection{Ermitteln der Kostenstruktur}
%\blindtext\

%\subsubsection{Kostenberechnung}
%\blindtext\

\subsubsection{Zusammenstellen des Kostenplans}
Der Kostenplan{\footnote{\extendedref{sec:Projektkosten Details}}} teilt sich ein in die personellen (oben) und nicht personelle Aufwendungen (unten). Es wird davon ausgegangen, dass bei einem Stundenlohn von ca. 40€ immer mindestens ein Kollege für die fachliche Unterstützung zur Verfügung stehen. Die Unterstützung erfolgte dabei in offiziellen Meetings, aber auch spontan im Büro, wenn Gesprächsbedarf bestand. Ebenso verhält es sich mit dem Ausbilder, der für die Betreuung während des Projektes zuständig war und einen etwas höheren Stundenlohn erhält. Dabei muss erwähnt werden, dass ich es für das Betriebsklima nicht als sinnvoll erachtet habe, jede Beteiligte nach ihrem exakten Stundenlohn zu fragen. Die Lösung war daher, den \acs{PO} nach gewöhnlichen Stundenlöhnen zu fragen, die im Unternehmen üblich sind. Obgleich ich meine Ausbildung vom Staat finanziert wird, ist es hier zielführend, einen durchschnittlichen Stundenlohn eines Praktikanten anzugeben, um zu gewährleisten, dass die Beträge auch für durchschnittliche zukünftige Projekte dieser Größenordnung aussagekräftig sind.\newline\newline Im Kostenplan wird davon ausgegangen, dass Personal nicht nur über das Gehalt Kosten generiert, sondern dass auch Betriebskosten, wie Strom, Wartung der verwendeten Technik, Heizung im Büro u. Ä. Kosten verursachen. Daher wird ein pauschaler Handlungszuschlag von 30\% auf den Lohn angenommen. Natürlich könnte man an dieser Stelle einwenden, dass der Handlungszuschlag in Wirklichkeit stark schwanken kann, dennoch macht es Sinn im Hinterkopf zu behalten, dass neben dem Lohn auch weitere Kosten für den laufenden Betrieb in der Firma anfallen.\newline\newline Ebenfalls ist anzuführen, dass es sich bei dem  Bei der notwendigen Hardware und Software ist zu bemerken, dass es sich bei den ermittelten Beträgen nicht um Anschaffungskosten handelt, sondern jene Kosten, die Hard- oder Software für gewöhnlich in der Zeitspanne des Projektes in Anspruch nehmen. Außerdem handelte es sich bei den unterstützenden Entwicklern um Senior-Entwickler, deren Stundenlohn verhältnismäßig hoch ist. Der Kostenplan gibt also nicht wieder, was zusätzlich für Kosten angefallen sind, sondern wie kostenintensiv das Projekt innerhalb des laufenden Betriebs ist.

%\subsubsection{Nicht-monetäre Vorteile}
%\blindtext\
\subsubsection{Zeitersparnis}
Zunächst musste ermittelt werden, wie viel Zeit die derzeitige Entwicklung von Arche ohne einheitliche Datenbankkommunikation angefallen ist\footnote{\extendedref{sec:Zeitersparnis}}. Hier hat sich gezeigt, dass Tickets, bei denen datenbanksensible Prozesse gewartet werden müssen, relativ häufig vorkommen. Hier kann es z.B. vorkommen, dass ein Kunde glaubt, Daten abgespeichert zu haben, die Änderungen der jene Daten jedoch nicht im System sichtbar zu sein scheinen. Für diesen recht frequenten Fall muss die entsprechende Query oft langwierig durch im Debugging-Modus isoliert werden. Es konnte herausgefunden werden, dass das Identifizieren der Queries im Debug-Modus pro Ticket immer mindestens 10 Minuten vergehen und dies etwas weniger als alle zwei Arbeitstage vorkommt.\newline\newline Zudem wird davon ausgegangen, dass monatlich 2 neue Persistence-Klassen hinzukommen bzw., da es sich um Legacy-Software handelt, gewartet werden müssen. Hierfür werden nach der bisherigen manuellen Vorgehensweise Spaltennamen per Copy-Paste von SSMS nach Visual Studio übertragen, was für jede der beiden monatlich bearbeiteten Klassen einmal geschieht. Folgende in der Tabelle aufgeführten Arbeitsschritte müssen jeweils für Insert-, Update- und Delete-Queries ausgeführt durchgeführt werden, wodurch diese jeweils 6 mal pro Monat durchgeführt werden. Durch das Automatisieren der genannten Prozesse konnte der meiste zeitliche Aufwand reduziert werden und insgesamt 778 Minuten pro Monat an Einsparungen errechnet werden.

\subsubsection{Amortisation}
Mit der ermittelten zeitlichen Einsparung konnte nun eine Rechnung darüber erstellt werden, wann die Schuld der Projektkosten voraussichtlich getilgt ist. Beim Stundenlohn wird nun wieder das ermittelte Seniorentwicklergehalt von 40 € pro Stunde angenommen, sowie ein Handlungszuschlag von 30\%. Auch hier kann man davon ausgehen, dass für zukünftige Projekte auch Entwickler mit moderateren Gehältern beteiligt werden können. Der zufällige Vorteil dieser Konstellation ist jedoch, dass vergleichbare Projekte tendenziell günstiger werden als teurer. Wenn nun also davon ausgegangen wird, dass das Projekt insgesamt 2443,00 € betragen, die reguläre Entwicklung jedoch 8091,20 €/Jahr kostet, dann ist davon auszugehen, dass die Projektkosten nach etwa 3 1/2 Monaten wieder wett sind:%\clearpage

\begin{align}
    778\frac{Minuten}{Monat}\cdot 12\frac{Monate}{Jahr}&=9336\frac{Minuten}{Jahr}=155,6\frac{Stunden}{Jahr}
\end{align}
\begin{align}
    155,6\frac{Stunden}{Jahr}\cdot(40 \text{\euro} + 12 \text{\euro})&=8091,20\frac{\text{\euro}}{Jahr}
\end{align}
\begin{align}
    \frac{2443,00 \text{ \euro}}{8091,20 \frac{\text{\euro}}{Jahr}}=0,30 \text{ Jahre}
    \approx 3 \text{ Monate}, 18 \text{ Tage}
\end{align}
%
Auch hier muss realistischer Weise eingeschränkt werden: Natürlich ist dieses IHK-Projekt eines von mehreren Optimierungsvorhaben, die an Arche vorgenommen werden. Wie bereits erwähnt, wird ein langfristiges Vorhaben sein, die App in eine ASP.NET-Architektur zu überführen, was ebenfalls mit Änderungen Zeit und Kosten einhergeht. Die Amortisationsrechnung stellt also eine Annäherung an die wirtschaftlichen Verhältnisse dar, die durch das Projekt beeinflusst werden.

%\subsection{Anwendungsfälle}
%\blindtext\

%\subsection{Lastenheft}
%\blindtext\

%\subsection{Risikomanagement}
%\blindtext\

%\subsubsection{Risikoerkennung}
%\blindtext\

%\subsubsection{Risikoanalyse}
%\blindtext\

%\subsubsection{Risikominimierung}
%\blindtext\

\section{Entwurfsphase}
Für den Programmentwurf muss zunächst zwischen dem Auffinden von Queries und dem automatisierten Generieren von \gls{SqlCommand}-Objekten unterschieden werden. Beim Query-Tracing geht es darum, datenbanksensible Module schneller warten zu können und eine akkurate Rückmeldung über entsprechende Datenbankabfragen zu erhalten. Liegt hier ein Entwurf vor, wird dazu übergegangen, generell die Datenbankschnittstelle zu vereinheitlichen und mit Hilfe von Datenbankmodellen, automatisch SqlCommand-Objekte zu erzeugen. Die so entworfene Logik, soll dann global für alle Datenbankprozesse gelten.

\subsection{Query-Tracing}
Das Auffinden von Queries, die zu einem bestimmten Zeitpunkt von Arche an den SQL-Server geschickt werden, soll so organisiert werden, dass die Entwicklerin nicht mehr den Debug-Modus starten muss, um eine Query zu identifizieren. Allein durch einen einzigen Boolean soll sich das Query-Tracing ein- und ausschalten lassen. Sobald das Query-Tracing aktiviert ist, kann in Arche jedwede datenbanksensible Funktion ausgelöst werden, ohne dass Daten verändert werden. 

\subsubsection{Anwendungsfall}
Der konkrete Anwendungsfall\footnote{\extendedref{fig:Anwendungsfalldiagramm}} sieht folgendermaßen aus: Ein dafür vorgesehener \gls{Boolean} wird vom Entwickler auf \glqq true\grqq{} gesetzt und damit das Query-Tracing aktiviert. Nun kann es sein, dass die entsprechende Persistence-Klasse, die die Datenbankkommunikation steuert, bereits ein kleines Code-Fragment enthält, durch das das Query-Tracing-Modul zum richtigen Zeitpunkt aktiviert wird. Oder es handelt sich um eine bisher noch nicht refaktorierte Klasse, und der Entwickler muss das in der Dokumentation hinterlegte Code-Fragment noch in die entsprechende Klasse einfügen. Oder es liegt der Fall vor, dass eine andere Entwicklerin bereits mit dieser Klasse gearbeitet hat und daher keine Code-Fragmente eingefügt werden müssen. Nun kann die Entwicklerin Arche in Visual Studio starten und die im zu bearbeitenden datenbanksensible Funktion\footnote{Dabei handelt es sich v. a. um \glqq Suchen\grqq{}-, \glqq Speichern\grqq{}- und \glqq Löschen\grqq{}-Buttons.} auslösen wodurch in jedem Fall ein Tracing-Fenster geöffnet wird. Dieses soll nun detaillierte Informationen über die momentane Query ausgeben. Zusätzlich stehen diverse Funktionen zur Verfügung. Obgleich das Modul sicherstellen soll, dass nicht ungewollt Queries an den Datenbankserver geschickt werden, kann man sich dennoch dafür entscheiden, eine Query ausführen zu lassen. Select-Queries verursachen keine Änderungen an Daten und es kann sein, dass sich der Entwickler bei Insert-, Update- oder Delete-Queries sicher ist, dass diese keine unerwünschten Folgen für die Kundin haben.\newline\newline Für den ersteren Fall soll das Modul den Select-Befehl automatisch erkennen und die keine Möglichkeit zum Unterdrücken der Query geben. Für die übrigen Fälle, soll man frei entscheiden können. Weiterhin kann der Entwickler sich die Query automatisch bei jeder Nutzung des Query-Trackers in die Zwischenablage kopieren lassen. Ebenfalls wichtig wird die Funktion sein, die Query nach \acs{SSMS} zu kopieren, um von dort aus mit ihr weiterarbeiten zu können\footnote{De facto soll in diesem Fall in Windows immer das Programm die Query öffnen, das in den Systemeinstellungen als Standardprogramm für .sql-Dateien vorgesehen ist. Je nach Konfiguration kann es sich also auch um ein anderes \gls{Datenbank Management System} handeln.}.\newline Möchte der Entwickler auf seinem lokalen Rechner die in Arche genutzte Datenbankstruktur nutzen, besteht die Möglichkeit durch Klick auf den entsprechenden Button, eine Query nach SSMS zu übertragen, die die Struktur des Datenbank gefiltert nach noch in Verwendung befindlichen Tabellen.

\subsubsection{Architekturdesign}
Um die Entwicklerinnen sinnvoll zu unterstützen, soll die Architektur\footnote{\extendedref{fig:Query-Tracing-Klassen}} so gestaltet werden, dass eine sinnvolle Hervorhebung von datenbankrelevanten Keywords eingebaut wird. Zudem sollen sinnvolle Zeilenumbrüche bei entsprechenden Keywords dafür sorgen, dass für die Query wesentliche logische Einheiten schnell sichtbar werden. Hierfür soll in QueryTracing.cs eine einfache \gls{List} mit Namen \glqq sqlKeywords \grqq{} die wichtigsten SQL Keywords speichern. Diese sollen dann in der \glqq QueryInfoforms.cs\grqq{} von \glqq SetColorForKeywords\grqq{} erkannt und markiert werden. Dabei sollen nur zwei Elemente öffentlich sein: Der Boolean \glqq isActive\grqq{} und die Funktion \glqq SuppressQuery\grqq{}. Der Boolean aktiviert und deaktiviert das Modul, die Funktion setzt alle übrigen Prozesse in Gang, die GUI auf der rechten Seite eingeschlossen. Die anderen Daten oder Methoden sind entweder \glqq private\grqq{} (nur innerhalb der Klasse verfügbar) oder \glqq internal\grqq{} (nur innerhalb des Moduls DBEncapsulation verfügbar).

\subsubsection{Lokale Datenbank für Simulationsmodus}
Mit Klick auf den Button \glqq Create local database...\grqq{} soll eine spezifische Query zum Erzeugen der lokalen Datenbank nach SSMS übertragen. Beim Erzeugen dieser Datenbank wird nur die Struktur der Arche-Datenbank übertragen, nicht deren Inhalt\footnote{Der Fachbereich Systemintegration von Argus geht davon aus, dass der Inhalt der Arche-Datenbank mehrere Petabytes umfasst und darüber hinaus als Verbund mehrerer Datenbanken zu verstehen ist. Daher ist nur das lokale Simulieren der Struktur sinnvoll.}. Angedacht ist, dass die Entwickler die entsprechende Query nicht mehr zu bearbeiten brauchen, sondern lediglich einen Namen und einen Speicherort vergeben müssen, um hinterher gezielt einzelne Datensätze von der Live-Datenbank auf die lokale Datenbank zu übertragen. Hinterher können die vom Query-Tracer abgefangenen Queries einfach nach SSMS kopiert werden, um diese dann auf der lokalen Umgebung auszuführen. 

\subsection{Command-Generator}
Nach dem Entwurf des obigen Knotenpunktes zur Überwachung der Queries kann nun die Architektur für den Command-Generator entworfen werden. Dieser soll Objekte der Klasse \gls{SqlCommand} erzeugen. Dabei handelt es sich um eine .NET-Klasse, die in der Lage ist, diverse datenbankrelevante Parameter\footnote{U. a. \gls{Connection String}, Servername, Datenbankname, Tabellennamen, Spaltennamen, Query.} zu speichern, die für die Datenbankkommunikation erforderlich sind. Es soll ab sofort nicht mehr notwendig sein, Update-, Insert- oder Delete-Queries manuell zu schreiben. Ebenso wenig soll es notwendig sein, die Spaltennamen und deren Datentyp zu kennen oder gar manuell von SSMS nach Visual Studio zu übertragen. Für jede noch in Benutzung befindliche Tabelle soll ein Modell erzeugt werden, dessen Klassenname dem Tabellennamen entspricht. Der SQL-Datentyp soll automatisch in einen .NET-Datentyp überführt werden und für jede Tabelle eine .cs-Datei abgespeichert werden, auf dessen Basis dann Queries und Parameter für die SqlCommand-Klasse generiert werden können.

\subsubsection{Entwurf der Konvertierungslogik}
Das Generieren von Models bedeutet für dieses Projekt, dass auf Basis des Datenbankschemas von Arche pro Tabelle eine .cs Datei erzeugt wird mit einer Klasse und mindestens eine Property. Diese besteht wiederum dem \gls{Access-Modifier} \glqq public\grqq{}, aus einem .NET-Datentyp, eventuell einer nullable-Information, einem Bezeichner und jeweils Getter und Setter\footnote{In .NET werden Getter und Setter nicht unabhängig von den entsprechenden Daten deklariert, sondern sind die Architektur von .NET integriert.}. Im folgenden drei Beispiele für Column-Properties mit jeweils unterschiedlichem Datentyp:
\newline\newline
public Guid? OID \{ get; set; \}\newline  
public string Status \{ get; set; \}\newline
public DateTime sys\_created \{ get; set; \}\newline\newline
Wie erwähnt sind Getter und Setter immer gleich, selbiges gilt für den Access-Modifier. Für jede Property anders sind Datentyp, nullable (das Fragezeichen) und der Bezeichner. Die obige Übersicht soll aus den folgenden Sql-Daten konvertiert werden können:\newline
\begin{table}[ht]
    
    \begin{tabular}{l|l|l|l}
        TABLE\_NAME & DATA\_TYPE & IS\_NULLABLE  & COLUMN\_NAME  \\
        AuftragDimension & uniqueidentifier & YES  & OID  \\
        AuftragDimension & varchar & YES  & Status  \\
        AuftragDimension & datetime & NO  & sys\_created  \\
    \end{tabular}
    %\caption{Caption}
    %\label{tab:my_label}
\end{table}\linebreak
Dabei muss angemerkt werden, dass .NET Strings immer als nullable ansieht und hier das Fragezeichen wegfällt. Für die Konvertierung des Datenbankschemas zu .NET-Models könnte selbstverständlich auch ein in C\# geschriebenes Programm dienen. Da es sich hier jedoch nicht um eine Funktionalität handelt, die Arche später ausführen können soll (denn Arche wird nur mit den Models als .cs-Dateien arbeiten), kann auch eine andere Programmiersprache gewählt werden. Da es dabei nicht unbedingt notwendig ist, komponentenorientiert zu arbeiten und der Datentyp innerhalb des Konvertierungsskripts nicht festgelegt sein muss (der Inhalt der obigen Tabellen wird immer als string behandelt), bietet sich Python an. Der Vorteil dieser Programmiersprache liegt darin, dass kein gesondertes Projekt angelegt werden muss. Auch ist keine strikte Datenkapselung vonnöten. Viel mehr fördert der kurze lesbare Stil von Python in diesem Fall die schnelle Umsetzung des Entwurfs.

\subsubsection{Entwurf für das Erstellen von Models}
Für das Struktogramm\footnote{\extendedref{fig:Struktogramm .NET-Models erzeugen}}, durch das .NET-Models erzeugt werden sollen, ist es notwendig, mit einer Liste von .NET-Properties zu arbeiten. Denn jede Klasse, die ein Model repräsentiert, enthält mindestens eine Property (analog hat jede Tabelle mindestens eine Spalte). Das Ergebnis des Datenbankschemas ist, wie oben zu sehen, so organisiert dass als erste Position immer aufs neue der Tabellenname erscheint, solange bis jeder in dieser Tabelle vorhandene Spaltenname auf der rechten Seite erschienen ist. Das Skript muss also in der Lage sein zu erkennen, welche Zeilen aus dem Ergebnis zu einer .cs-Datei gehören. Das geschieht, in dem der Tabellenname (oben \glqq AuftragDimension\grqq{}) als Variable zwischengespeichert werden soll. Sobald eine Zeile abgearbeitet ist, wird geprüft, ob der Name der temporären Tabelle mit dem Namen der folgenden Tabelle übereinstimmt.\newline\newline Ist dies der Fall, wird die Property nur zur Liste hinzugefügt und die nächste Zeile bearbeitet. Sind die Namen unterschiedlich oder die letzte Zeile ist erreicht, bedeutet dies, dass die Tabelle (und somit der Inhalt der zu erstellenden .cs-Datei) fertig bearbeitet ist. Die Liste der Properties und der Tabellenname wird nun einer weiteren Liste .NET-Models hinzugefügt. Dies soll solange geschehen, bis alle Tabellen abgearbeitet sind.

\subsubsection{Entwurf für den Query-Generator}
Jedes Objekt der .NET-Klasse SqlCommand enthält eine Query. Dabei kann es sich um eine Query handeln, die ohne weiteres vom Datenbankserver verarbeitet werden kann oder um eine schematische Query, die nur durch Hilfsmittel, wie dem in diesem Projekt entwickelten Query-Tracers, gelesen werden kann. Die schematische Query sieht dabei so aus, dass bei der Zuweisung von Werten zu Spalten auf der linken Seite wie gewohnt die Spalte aufgeführt ist, auf der rechten Seite links vom Gleichheitszeichen jedoch kein Wert, sondern ebenfalls der Spaltenname mit einem @-Symbol davor (z.B. \glqq sys\_created=@sys\_created\grqq). D.h. die Query in SqlCommand-Objekt dient noch nicht zur Ausführung. Sie soll lediglich bereit stehen, um zum gegebenen Zeitpunkt mit Werten gefüllt zu werden, die der Nutzer in der GUI des entsprechenden Workflows eingibt. Durch die spezifische Schreibweise kann .NET dann das @-Zeichen und den folgenden Spaltennamen durch den gewünschten Wert ersetzen.\newline\newline Der Query-Generator braucht nun zwei Informationen: \textit{Welche Art von Query soll erzeugt werden (Insert, Update oder Delete)?} und \textit{Wie lautet der Tabellenname?} Der Tabellenname entspricht jeweils dem Klassennamen der entsprechenden .cs-Datei, die nach erfolgreichem Erstellen der oben beschriebenen Models vorliegen soll. Dabei ist in der Regel davon auszugehen, dass alle drei Typen erzeugt werden sollen. Es ist wichtig darauf hinzuweisen, dass es sich bei den Informationen aus den Models nicht um Werte handelt, die aus den entsprechenden Properties abgespeichert sind. Es muss für das Erstellen von SqlCommand-Objekten auch kein Objekt dieser Models erzeugt werden. Lediglich die Bezeichnung von Klasse und Properties auf String-Ebene ist hier entscheidend. Anhand dieser Informationen kann der Query-Generator entsprechende Queries erstellen. Die Klasse\footnote{\extendedref{fig:Klassendiagramm}} ist dabei so organisiert, dass mehrere Hilfsklassen als Datentypen innerhalb von QueryRequest deklariert werden. Diese werden in Lists abgelegt, die der Query-Generator iterieren kann.\newline\newline So können beispielsweise alle Spalten für eine Insert-Query iteriert werden, indem der Query-Generator zwei strings, \glqq columns\grqq{} und \glqq values\grqq{} initialisiert, die beide mit einer öffnenden Klammer beginnen. Nun sollen alle Spalten jeweils für beide Variablen iteriert werden, wobei die values Variable, die oben aufgeführte Schreibweise mit \glqq [spalte]=@[spalte]\grqq{} verwendet. Anschließend sollen beide Strings eine schließende Klammer erhalten. Die schematische Query kann dann an das SqlCommand-Objekt übergeben werden.

%\subsubsection{Entwurf Modul Transformation}
%\blindtext\

%\subsection{Roundtrip Engineering}
%\blindtext\

%\subsection{Pflichtenheft}
%\blindtext\

\section{Implementierung}
Für die Implementierung wurde so vorgegangen, dass zunächst das Query-Tracing, dann die Query-Request-Klasse und zuletzt der Command-Generator mit dem darin enthaltenen Query-Generator implementiert wurde. Diese Reihenfolge wurde gewählt, um den Query-Tracer nach Fertigstellung sogleich auch als Testumgebung für die vom Query-Generator erzeugten Queries zu verwenden.

\subsection{Implementierung des Query-Tracers}
Die GUI\footnote{\extendedref{fig:GUI Query-Tracer}} wurde so umgesetzt, dass die Textbox, welche die Query anzeigt, den meisten Raum einnimmt. Um jedoch nicht allzu sehr andere möglicherweise noch geöffneten Fenster zu überlagern, wird die Query ab einer maximalen Länge gescrollt. Datenbankname und Serverame sind immer ersichtlich, ebenso wie der Connection String. Innerhalb der Query werden alle SQL-Keywords erkannt und farblich markiert. Die Farben wurden dabei an diejenigen aus SSMS angelehnt. Das Fenster öffnet sich immer dann, wenn eine Query von Arche an den Datenbankserver verschickt werden würde. Damit der Query-Tracer verwendet werden kann, ist ein kleines Code-Fragment\footnote{\extendedref{fig:Code zum Aktivieren des Query-Tracers}} in die Persistence-Klasse einzufügen. Im Falle von Select-Queries wird die Query immer an den Datenbankservers geschickt. Insert, Update und Delete können unterdrückt werden und führen bei Klick auf den entsprechenden dazu, dass \glqq SuppressQuery\grqq den Wert \glqq true \grqq{} annimmt und die datenbanksensible Funktion der Persistence-Klasse abgebrochen wird. Arche erhält den Wert \glqq 0\grqq{} zurück als Anzahl der veränderten Zeilen.\newline\newline Für die Entwicklerinnen ist es von Vorteil, wenn in SSMS nicht erst die entsprechende Datenbank ausgewählt werden werden muss, um die Query in SSMS erfolgreich auszuführen\footnote{.NET übergibt den Datenbanknamen nicht in der Query, sondern in einem gesonderten Parameter.}. Daher wird der Datenbankname (hier: \glqq ArcheDB\grqq{}) an der entsprechenden Stelle eingefügt. Der Query-Tracer sucht dabei schlicht nach dem Schlüsselwort \glqq from\grqq{} und fügt den Datenbanknamen gemäß den Konventionen von SSMS mit zwei Punkten zur Query hinzu.

\subsection{Kodierung der Methode zum Erzeugen von Table-Models}
Die Methode zum Erzeugen von Table-Models wurde nun in Python kodiert\footnote{\extendedref{fig:Methode zur Erzeugung von Table-Models}}. Dabei hat sich gezeigt, dass nicht alle in klassischen Struktogrammen bekannten Konventionen in einer \gls{Dynamisch} geschriebenen Programmiersprache wie Python zur Geltung kommen. So gibt es keine Unterscheidung von Deklaration und der Zuweisung von Werten. Ebenso war es nicht notwendig, jede einzelne Kontrollstruktur explizit mit \glqq if\grqq{} oder \glqq else\grqq zu kodieren. Bei booleschen Werten konnte die im Struktogramm vorliegende Verzweigung oft mit nur einer Zeile umgesetzt werden. Darüber hinaus muss im Gegensatz zum Struktogramm auch \glqq try \grqq{} und \glqq catch \grqq{} unterschieden werden\footnote{Hier beim Iterieren der Zeilen: \textit{Ist in der Zeile darunter eine andere Tabelle als die aktuell bearbeitete Tabelle?} Wenn bereits die letzte Zeile bearbeitet wird, muss eine Index-Exception abgefangen werden.}.\newline Sobald in der linken Spalte eine neue Table erscheint oder die letzte Zeile erreicht ist, werden alle gesammelten Properties in einer Liste als Parameter für die Klasse \glqq DotNetModel\footnote{\extendedref{fig:DotNetModel}}\grqq{} übergeben, dass aus den Models den C\#-Code erzeugt. Ein ursprünglich angedachtes \gls{Dictionary}, das auf der einen Seite .NET-Datentypen und auf der anderen Seite SQL-Datentypen enthalten sollte, musste hier nicht umgesetzt werden. Aufgrund der zeichenarmen Syntax von Python war es ausreichend, die Datentypen mit simplem \glqq if \grqq{} und \glqq elif \grqq{} zu assoziieren\footnote{\textit{if SqlDataType == \grq varchar\grq{}: DotNetDataType = \grq string\grq{}} usw.}. 


\subsection{Implementierung des Query-Generators}
Nach der erfolgreichen Implementierung der oben beschriebenen Model-Generators konnte nun der Query-Tracer kodiert werden. Dieser nimmt ein Objekt der in \ref{fig:Klassendiagramm} dargestellten Query-Request-Klasse. Queries sollen mit Hilfe der nun erstellten Models für die Typen \glqq insert\footnote{\extendedref{fig:Insert-Methode}}\grqq{}, \glqq update \grqq{} und \glqq delete \grqq{} erzeugt werden. Bei der Implementierung zeigt sich ein entscheidender Vorteil der automatischen Generierung gegenüber dem manuellen Verfassen einer Query:\newline Es ist nun sowohl unmöglich geworden, falsche Bezeichnungen für Tabelle oder Spalte zu wählen. ist keine entsprechende .cs-Datei vorhanden, die die Tabelle repräsentiert, wird der entsprechende Versuch unterringelt. Spaltennamen brauchen nun ebenfalls nicht mehr von der Programmierin eingegeben werden und es kann zudem nicht vorkommen, dass die Reihenfolge Spalte und zuzuordnendem Wert nicht übereinstimmt. Es muss lediglich bekannt sein, um welche Tabelle es sich handelt und sie kann nach Eingeben der ersten Buchstaben durch die \gls{IntelliSense} ausgewählt werden.

\subsection{Hinzufügen von Spalten und Datentyp zum SqlCommand-Objekt}
Nachdem es nun möglich ist, Queries zu erzeugen, können jetzt die Spalten mit ihrem jeweiligen Datentyp dem Objekt der .NET-Klasse SqlCommand hinzugefügt werden. Dazu müssen die nun im .NET-Datentyp vorliegenden Properties wieder in den Sql-Datentyp überführt werden\footnote{Für die Zuordnung von .NET-Datentyp zu SQL-Datentyp siehe \cite{Microsoft2021}.}. Dabei werden nun alle Properties iteriert, deren Bezeichnung als Parameter mit einem @-Symbol an das Objekt übergeben und der entsprechende Datentyp wieder zur Sql-Architektur hinzugefügt. Auch hier ist zu bemerken, dass es beim Iterieren der Models keinesfalls um den Inhalt irgendeiner Variable geht. Ausschließlich die Zeichenketten von Bezeichner und Datentyp sind hier entscheidend. Der Bezeichner der Property (z.B. \glqq enthaeltUeberschrift\grqq{}) entspricht also der gleichnamigen Tabelle in der Datenbank. Der .NET-Datentyp \glqq Boolean\grqq{} wird durch ein entprechendes \gls{Dictionary} in den Datentyp \glqq bit\grqq{} überführt.

%\subsection{Implementierung Hilfsklassen und Interfaces}
%\blindtext\

\section{Qualitätssicherung und Abnahme}
Um höchstmögliche Qualität bei der Datenbankkommunikation zu gewährleisten, war es sinnvoll, sowohl eine erfahrene Entwicklerin, als auch die in der Firma zuständige Datenbankexpertin, sowie den \gls{PO} in den Prozess der Qualitätssicherung\footnote{\extendedref{fig:Sequenzdiagramm Entwicklung und Tests}} mit einzubeziehen. Grundsätzlich wird davon ausgegangen, dass die erfahrene Entwicklerin besonders im Bereich .NET unterstützend eingreifen kann, während die Datenbankexpertin natürlich die Qualität des entwickelten Moduls im Bereich SQL prüfen kann. Zunächst wird so vorgegangen, dass der Entwickler (der Praktikant) eigenständig die in dieser Dokumentation dargestellten Features entwickelt. In unregelmäßigen Abständen werden die Ergebnisse der erfahrenen Entwicklerin präsentiert, die die Funktionalität innerhalb von .NET bewerten kann und Rückmeldung bezüglich Bugs und Kodierstil geben kann.\newline\newline Dieser Vorgang wird so oft durchgeführt wie Entwicklungsbedarf vorhanden ist. Sobald das Modul innerhalb von .NET die gewünschte Qualität erreicht hat, kann der Entwickler Stichproben der mit dem Command-Generator erstellten Objekte von der Datenbankexpertin bewerten lassen. Diese kann die nun automatisch generierten Sql-Command-Objekte mit manuell kodierten Objekten vergleichen. Der QueryTracer\footnote{\extendedref{fig:GUI Query-Tracer}} dient dabei als Hilfsmittel, um manuell automatisch generierte und und manuell geschriebene Queries zu vergleichen. Alle übrigen Attribute des Sql-Command-Objekts werden mit Hilfe der \gls{Intellisense} geprüft. Ist die Prüfung durch die Datenbankexpertin abgeschlossen, wird vom Entwickler ein \gls{Pull Request} erstellt, welcher von der erfahrenen Entwicklerin bearbeitet wird. Auch diese Arbeitsschritte werden so lange durchgeführt, bis sowohl die erfahrene Entwicklerin, als auch die Datenbankexpertin zufrieden sind. Sind beide Schleifen durchlaufen wird der PO über die Ergebnisse unterrichtet. Er hat nun auch die Möglichkeit mit der Datenbankexpertin im 4-Augen-Gespräch zu entscheiden, ob das neue Modul in den Mainbranch integriert wird.

\begin{comment}


%\subsection{Systemtest}
%\blindtext\

%\subsection{Tests gegen das System}
%\blindtext\

%\subsection{Testprotokolle}
%\blindtext\

%\section{Abnahme}
%\blindtext\

%\subsection{Soll/Ist-Vergleich}
%\blindtext\

%\subsection{Abnahme durch den technischen Leiter}
%\blindtext\
\end{comment}

\section{Entwickler-Dokumentation}
Für die Entwickler-Dokumentation\footnote{\extendedref{fig:Dokumentation}} des Moduls wurde die Markiersprache Markdown gewählt. Diese ist leicht zu erlernen und kann zudem einfach in Web-Oberflächen wie Confluence oder Jira eingebunden werden. Zum Erstellen der Markdown-Datei wurde mit Visual Studio Code gearbeitet. Wird ein entsprechendes Mark-Down Plugin als Erweiterung installiert, kann auf der linken Seite das Markdown-Skript bearbeitet werden. Auf der rechten Seite kann die Entwickler-Dokumentation eingesehen werden, so wie sie die Entwickler sehen werden. Die Mitarbeiterinnen und Mitarbeiter von Argus bilden ein internationales Team, das auf Englisch kommuniziert (es sei denn, es sind gerade nur deutschsprachige Kommunikationsteilnehmer zugegen).\newline Die Entwickler-Dokumentation ist entsprechend ebenfalls auf Englisch. Sie unterscheidet, wie diese Projektdokumentation, zwischen dem Query-Tracer und dem Command-Generator. Im Falle des Query-Tracers sind neben dem Text auch einzelne Screenshots aus der GUI verfügbar. Beim Command-Generator sind zudem mehrere Code-Fragmente vorhanden, die für die Erstellung neuer Persistence-Klassen benötigt werden. Das in dieser Projektdokumentation dargestellte Verfahren, nach dem der Command-Generator funktioniert, ist in verkürzter, handlungsorientierter Form in der Entwickler-Dokumentation auf Englisch mit enthalten.

%\subsection{Technische Dokumentation}
%\blindtext\

%\subsection{Nutzerdokumentation}
%\blindtext\

\section{Fazit}
Im Laufe des Projektes sind mal mehr technische, mal mehr organisatorische Herausforderungen in den Vordergrund gerückt. Im Folgenden soll ein Überblick über den Soll- und Ist-Zustand am Ende des Projektes, sowie mögliche Erweiterungen für die Zukunft gegeben werden.

\subsection{Abschließende Bewertung des Projekts}
Im Wesentlichen hat es sich als sehr nützlich herausgestellt, die Expertise von Kolleginnen und Kollegen in das Projekt mit einfließen zu lassen. Unterm Strich konnte so die in \ref{fig:Sequenzdiagramm Entwicklung und Tests} aufgeführte Vorgehensweise eine vollwertige Kapselung der Datenbankkommunikation gewährleisten. Dennoch muss bei den angestrebten Funktionalitäten differenziert werden. Es ist zwar möglich, einen Simulationsmodus mit Hilfe des Query-Tracers aufzubauen, jedoch setzt dieser mehr technisches Wissen vom Entwickler voraus, als zu Beginn des Projektes angedacht. Dies ist zwar grundsätzlich kein großes Problem, denn der Umgang mit SSMS und SQL im Allgemeinen ist den Mitarbeitern bekannt, doch konnte durch die teils manuelle Einrichtung des Simulationsmodus nicht der Komfort erreicht werden, der ursprünglich angedacht war. 

\subsection{Ausblick}
Während die Datenbankkommunikation nun zu großen Teilen auf Models basiert, ist die generelle Architektur von Arche noch nicht einheitlich für die Verwendung von Models konzipiert. Es besteht weiterhin das in \ref{fig:PrintmedienTreffer.cs} aufgeführte Problem der uneinheitlichen Speicherung verschiedener Daten an verschiedenen Stellen im Code, mit Bezeichnern, die nicht gänzlich mit Tabellen- oder Spaltennamen übereinstimmen. Eine wichtige Aufgabe für den geplanten Übergang von WinForms nach ASP.NET und Angular wird also sein, alle persistenten Daten, immer mit Hilfe von Models zu speichern, die vorher aus dem entsprechenden Datenbankschema generiert wurden. Darüber hinaus ist es sinnvoll, mittelfristig eine Logik zu erarbeiten, wie das Frontend über ein einheitliches Prinzip, die Models ansteuert, ohne sich allzuviel mit dem Backendcode beschäftigen zu müssen. Was die Unternehmenskultur anbelangt, wird es Sinn machen, den Fachbereich Datenbanken noch stärker mit dem Fachbereich Entwicklung zu verknüpfen.

%\subsection{Im Laufe des Projektes gewonnene Erkenntnisse}
%\blindtext

%\subsection{Ausblick}
%\blindtext

%\subsubsection{Von Anfang an geplante Weiterentwicklung}


%\subsubsection{Im Laufe des Projektes erkannter Weiterentwicklungsbedarf}
%\blindtext



\newpage
\setcounter{secnumdepth}{0}

\phantomsection
\addcontentsline{toc}{section}{Literatur}

\printbibliography



%\label{myLastPage}

\newpage

\pagenumbering{roman}

\setcounter{page}{1}
\setcounter{secnumdepth}{2}


\renewcommand{\thesection}{A}
\setcounter{section}{1}



\ofoot{\thepage}




\FloatBarrier
\section{Anhang}


\subsection{Detaillierte Zeitplanung}
\label{sec:Detaillierte Zeitplanung}
\begin{table}[ht]
	%\begin{center}
		\begin{tabular}{ l r }
			%\hline
			
			\textbf{Analysephase} 										& \textbf{7 h}	\\
			%\hline			
			\quad 1. Ist-Analyse												& 5 h			\\
			\quad 2. Kostenanalyse            								& 2 h			\\		
			\quad 3. Kommunikation mit dem Fachbereich						& 1 h			\\
			%\hline

			\textbf{Entwurfsphase} 										& \textbf{11 h}	\\
			%\hline
			\quad 1. Datenbanken sichten										& 1 h			\\
			\quad 2. Programmiersprachen und Frameworks auswählen				& 2 h			\\		
			\quad 3. Graphische Benutzeroberfläche skizzieren					& 2 h			\\
			\quad 4. Logik für Datenbankmodelle entwerfen						& 3 h			\\
			\quad 5. Konvertierungslogik der Datentypen erarbeiten            & 1.5 h			\\	
			\quad 6. Logiken für SQL-Command-Generierung skizzieren            & 1.5 h			\\	
			%\hline

			\textbf{Implementierungsphase} 								& \textbf{40 h}	\\
			%\hline
			\quad 1. GUI designen										            & 3 h 			\\
			\quad 2. Textformatierung einpflegen							        & 5 h 			\\
			\quad 3. Query-Verarbeitung programmieren 							& 4 h 			\\
			\quad 4. Andockstellen im bestehenden Code identifizieren			    & 2 h 			\\
			\quad 5. Query-Request-Klasse programmieren							& 6 h 			\\
			\quad 6. Skripte für das Generieren von Datenbankmodellen schreiben	& 7 h 			\\
			\quad 7. Query-Generator implementieren                               & 5 h 			\\
			\quad 8. Datenkonvertierung einbinden    						        & 4 h 			\\
			\quad 9. Refactoring der bestehenden Datenbanklogik               & 2 h 			\\
			\quad 10. Test der neuen Datenbankkommunikation						& 2 h 			\\			
			%\hline

			\textbf{Abnahme und Schulung}		 						& \textbf{2 h}	\\
			%\hline
			\quad 1. Abnahme durch Fachabteilung								& 1 h 			\\
			\quad 2. Installation												& 1 h 			\\
			%\hline

			\textbf{Erstellen der Dokumentation} 						& \textbf{10 h}	\\
			%\hline
			\quad 1. Erstellen der Projektdokumentation						& 8 h 			\\
			\quad 2. Erstellen der Entwicklerdokumentation					& 2 h 			\\
			
			%\hline

			\textbf{Gesamt}	 											& \textbf{70 h}	\\
			%\hline

		\end{tabular}
		\caption{Detaillierte Zeitplanung}
		
	%\end{center}
\end{table}	
\clearpage

\FloatBarrier
\subsection{Ressourcenplan}
\label{sec:Ressourcenplan}
\begin{table}[ht]
	%\begin{center}
		\begin{tabular}{ l }
			%\hline
			
			\textbf{Hardware} 										\\
					
			\quad 1. Rechner für die Softwareentwicklung (bereitgestellt durch Argus)														\\
			\quad 2. Rechner für die Dokumentation (bereitgestellt durch das bfw)            									\\		
			%\hline

			\textbf{Software} 										\\
			
			\quad 1. Microsoft Visual Studio 2019 Professional											\\
			\quad 2. Microsoft Visual Studio Code						\\		
			\quad 3. Microsoft SQL Server Management Studio 18						\\
			\quad 4. Pascal Brachet TexMaker 2021									\\
			\quad 5. Pluralsight Lernplattform (bereitgestellt durch Argus)		          			\\	
			\quad 6. Atlassian Source Tree    			\\	
			\quad 7. Draw.io (UML-Designer) \\
			\quad 8. Strutorizer (Struktogramm-Designer) \\
			
			%\hline

			\textbf{Programmiersprachen und Frameworks} 								\\
			
			\quad 1. .NET Framework 3.5										           		\\
			\quad 2. Python 3.9.7					       			\\
			\quad 3. pyodbc (Framework für die Anbindung von Python an MSSQL)\\
			\quad 4. WinForms (Grafische Benutzeroberfläche)\\
			%5. WinForms (Grafische Benututzeroberfläche)\\
			
			%\hline

			\textbf{Personal}		 							\\
			\quad 1. Entwickler\\
			\quad 2. Administratoren\\
			\quad 3. Ausbilder\\
			\quad 4. Praktikant\\
			%\hline
			\end{tabular}
		\caption{Ressourcenplan}
		
	%\end{center}
\end{table}	

\subsection{Auswahl der Integrierten Entwicklungsumgebung}
	\label{sec:Auswahl der Integrierten Entwicklungsumgebung}
\begin{center}
\begin{table}[ht]

	%\hline\hline
		\begin{tabular}{|| l | c | c | c | c | c | c | c ||}
	    \hline	
	    
	    \multicolumn{2}{||c|}{} & \multicolumn{2}{|c|}{Visual Studio 2019}  & \multicolumn{2}{|c|}{JetBrains Rider}  & \multicolumn{2}{|c||}{MonoDevelop}   \\
	    \hline
	    Kriterium & Gewichtung & Punkte & Gewichtet  & Punkte & Gewichtet & Punkte & Gewichtet \\
	    \hline
	    Preis & 20 & 1 & 20 & 2 & 40 & 5 & 100 \\
	    YouTube-Inhalte & 10 & 1,75 & 17,5 & 0,25 & 2,5 & 0,1 & 1 \\
	    Foreneinträge & 5 & 1 & 5 & 1 & 5 & 0,1 & 0,5 \\
	    Leichte Erlernbarkeit & 15 & 0,25 & 3,75 & 1 & 15 & 3,7 & 55,5 \\
	    Verbreitung & 30 & 4 & 120 & 2 & 60 & 0,1 & 3 \\
	    Mitgelieferte Features & 20 & 2 & 40 & 3,75 & 75 & 1 & 20 \\
	    \hline
	    Summe & 100 & 10 & \textbf{206,25} & 10 & 197,5 & 10 & 180 \\
	    
		\hline
		
		
	
		
			\end{tabular}
			\caption{Auswahl der Integrierten Entwicklungsumgebung}
			\end{table}
			\end{center}
		\clearpage




 
 

 
 


 
\subsection{Projektkosten Details}
	\label{sec:Projektkosten Details}
\begin{center}
\begin{table}[ht]

	%\hline\hline
		\begin{tabular}{|| p{27mm} | p{23mm} | r | r | r | r | r ||}
	    \hline	
	    
		\multicolumn{1}{||l|}{\textbf{Angefallen bei}}    &   \multicolumn{1}{|l|}{\textbf{Angefallen für}}  &   \multicolumn{1}{|c|}{\textbf{Std.}}  &  \multicolumn{1}{|c|}{\textbf{Lohn/Std.}}   & \multicolumn{1}{|c|}{\textbf{Lohn}} & \multicolumn{1}{|c|}{\textbf{Zschlg. 30\%}}    &   \multicolumn{1}{|c||}{\textbf{Summe}}   \\ 
		\hline
		
		
		Entwickler          & Fachliche\newline Unterstützung   &	4	& 40,00 €	& 160,00 €	    & 48,00 €	    & 208,00 €\\
		%\hline
		Ausbilder           &	Einarbeitung\newline Betreuung  &	8	& 45,00 €	& 360,00 €	    & 108,00 €	    & 468,00 €\\
		%\hline
		Praktikant          &	Durchführung \newline Projekt   &	70	& 10,00 €	& 700,00 €	    & 210,00 €	    & 910,00 €\\
		%\hline
		PO      &	Bereitstellung\newline Kosteninfo           &	2	& 60,00 €	& 120,00 €	    & 36,00 €	    & 156,00 €\\
		\hline%\hline
		Personal            &	                                &	84	& 155,00 €	& 1.340,00 €    & 402,00 €	    & 1.742,00 €\\
		\hline
		\multicolumn{6}{||l|}{Notebook für die Dokumentation}                                                       & 72,00 €\\
		\multicolumn{6}{||l|}{Desktop-PC für die Entwicklung}                                                       & 69,00 €\\
		\multicolumn{6}{||l|}{Infrastruktur Hardware (Netzwerk, VPN, Server, Verkabelung)}                          & 170,00 €\\
		\multicolumn{6}{||l|}{Peripheriegeräte (Docking Station, Maus, Tastatur, Headset)}                          & 190,00 €\\
		\multicolumn{6}{||l|}{Infrastruktur Software (Scrum-Tools, Windowslizenz)}                                  & 60,00 €\\
		\multicolumn{6}{||l|}{Visual Studio Professional Lizenz}                                                    & 140,00 €\\
		\hline
		\multicolumn{6}{||l|}{Technik}                                                                              & 701,00 €\\
		\hline
		\multicolumn{6}{||l|}{\textbf{Gesamt}}                                                                      &\textbf{2.443,00 €}\\
		\hline
		
			\end{tabular}
			\caption{Projektkosten Details}
			\end{table}
			\end{center}
			
				
			
	
	
		
		
		%\clearpage



\subsection{Zeitersparnis}
	\label{sec:Zeitersparnis}
%\begin{center}
\begin{table}[ht]
\centering
	%\hline\hline
		\begin{tabular}{|| l | r | r | r | r ||}
	    \hline
	    
		\textbf{Arbeitsschritt}                                     & \textbf{Mntl.} &\textbf{vorher} & \textbf{nachher} &\textbf{Gespart}\\
		\hline
		Identifizierung von Queries (Debug)                         & 36        & 10 min         & 2 min	         & 288 min\\
		Übertragen von Spaltennamen von SSMS nach VS2019            & 2         & 20 min         & 0 min	         & 40 min\\
		Verfassen der Insert-, Update- und Delete-Query             & 6         & 10 min         & 0 min	         & 60 min\\
		Manuelles Übertragen der Datentypen von SQL nach .NET       & 6         & 10 min         & 0 min	         & 60 min\\
		Hinzufügen der SQL-Parameter zu SQL-Command                 & 6         & 15 min         & 0 min	         & 90 min\\
		Prüfung der Daten durch Mitarbeiter                         & 6         & 40 min         & 0 min	         & 240 min\\
		\hline		
		\multicolumn{4}{||l|}{\textbf{Gesamtersparnis pro Monat}}                                                &\textbf{778 min}\\
		\hline
		
		
			\end{tabular}
			\caption{Zeitersparnis}
			\end{table}
			%\end{center}
			

\clearpage
\subsection{Anwendungsfalldiagramm}
In diesem Diagramm wird \glqq Query Tracer\grqq{} wie eine Person oder Firma behandelt. Dies ist insofern sinnvoll als dass die Entwicklerin nicht mit Argus, sondern mit firmeneigener Software interagiert. \glqq Lokale Datenbank erstellen\grqq{} könnte auch von \glqq Query Tracing aktivieren\grqq{} abhängen, ist andererseits aber auch ein eigenständiger Arbeitsschritt.
 \label{fig:Anwendungsfalldiagramm}

 \begin{figure}[htp]
 %\centering

	\includegraphics[scale=1.1]{Anwendungsfalldiagramm_2.png}
	 \caption{Anwendungsfalldiagramm}
 \end{figure}
 \clearpage
 
 \subsection{Query-Tracing-Klassen}
Übersicht über Backend- und Frontend-Logik von Query-Tracing. Diese \acs{UML}-artige Ansicht wurde mit Hilfe von Visual Studio erstellt. Befindet sich kein kleines graues Symbol rechts unten vom Hauptsymbol, ist der Inhalt \glqq öffentlich\grqq{}. Ein Herz bedeutet dem Modul \glqq intern\grqq{}, ein Schloss \glqq privat\grqq{}. Graue Daten stehen für GUI-Elemente.
 \label{fig:Query-Tracing-Klassen}

 \begin{figure}[htp]
 \centering

	\includegraphics[scale=0.8]{queryTracingClass.png}
	 \caption{Query-Tracing-Klassen}
 \end{figure}
 \clearpage
 

\subsection{Struktogramm .NET-Models-Generierung}
Dieses Diagram stellt schematisch das Erzeugen von .NET-Models dar. Da die Models mit der dynamisch geschriebenen Programmiersprache Python erzeugt wurden, kann Deklaration und Zuweisung von Werten zu Variablen zusammenfallen. Die Kodierung des Struktogramms ist in \ref{fig:Methode zur Erzeugung von Table-Models} aufgeführt.
 \label{fig:Struktogramm .NET-Models erzeugen}

 \begin{figure}[H]
 \centering
	\includegraphics[height=560, width=470]{struktogramm.png}
	 \caption{Struktogramm .NET-Models erzeugen}
 \end{figure}
 \clearpage
 
\subsection{Klassendiagramm QueryRequest}
Klassendiagramm der Klasse QueryRequest. Zu sehen sind Variablen und Methoden, sowie alle Klassen und Enumeratoren, die als Datentyp in QueryRequest verwendet werden.
 \label{fig:Klassendiagramm}

 \begin{figure}[H]
 \centering

	\includegraphics[scale=1.2]{UML-Klasse.png}
	 \caption{Klassendiagramm}
 \end{figure}
 \clearpage
 
\subsection{GUI Query-Tracer}
%Das zugrunde liegende GUI-Framwork ist WinForms. Die Symbole neben den Buttons stammen von Argus.
 \label{fig:GUI Query-Tracer}

 \begin{figure}[H]
 \centering

	\includegraphics[scale=0.9]{gui.png}
	 \caption{GUI Query-Tracer}
 \end{figure}
 \clearpage
 
 
 
 
   

    

 
\subsection{Sequenzdiagramm Qualitätssicherung}
 \label{fig:Sequenzdiagramm Entwicklung und Tests}

 \begin{figure}[H]
 \centering
	\includegraphics[scale=0.85]{Einfaches Sequenzdiagramm_2.png}
	 \caption{Sequenzdiagramm Qualitätssicherung}
\end{figure}%
\subsection{Auszug Entwickler-Dokumentation}
 \label{fig:Dokumentation}
 \begin{figure}[H]
 \centering

	\includegraphics[height=610, width=380]{doku.png}
	 \caption{Auszug Entwickler-Dokumentation}
 \end{figure}

\subsection{Auszug Projektabgrenzung}
 \label{fig:Assemblies}
Einige Komponenten aus Arche mit den Komponenten DBEncapsulation und DBEncapsulationTests:
 \begin{figure}[htp]
 \centering

	\includegraphics[scale=0.7]{Assemblies.png}
	 \caption{Assemblies und Referenzierung}
 \end{figure}
 \clearpage

 

 \subsection{Auszug PrintmedienTreffer.cs}
 \label{fig:PrintmedienTreffer.cs}
Mehrere Variablen aus der bereits vorhandenen PrintmedienTreffer-Klasse. Manche sind noch in Benutzung, andere sind obsolet:
 \begin{figure}[htp]
 \centering

	\includegraphics[scale=0.7]{PrintmedienTreffer.png}
	 \caption{PrintmedienTreffer-Auszug}
 \end{figure}
 \clearpage 


 
 

\subsection{Methode zur Erzeugung von Table-Models}
Kodierung des in \ref{fig:Struktogramm .NET-Models erzeugen} erarbeitetenden Struktogramms zur Erzeugung von Table-Models. 
 \label{fig:Methode zur Erzeugung von Table-Models}

 \begin{figure}[H]
 %\centering

	\includegraphics[scale=0.6]{modelGenerierung.PNG}
	 \caption{Methode zur Erzeugung von Table-Models}
 \end{figure}
 \clearpage

\subsection{Command-Generator Hauptmethoden}
Wesentliche Methoden des Command-Generators. Es wird das gewünschte Table-Model übergeben, sowie der gewünschte Query-Typ aus einem Enumerator. Query und SqlParameter werden entsprechend hinzugefügt:
 \label{fig:Command-Generator Hauptmethoden}

 \begin{figure}[H]
 %\centering

	\includegraphics[scale=0.6]{commandGenerator.PNG}
	 \caption{Command-Generator Hauptmethoden}
 \end{figure}
 
 \subsection{Code zum Aktivieren des Query-Tracers}
Dieses Code-Fragment wird in einer Persistence-Klasse eingefügt, an der Stelle bevor eine Query zum Datenbankserver geschickt wird. Die Variable \glqq anzahl\grqq{} stammt aus dem Legacy-Code.
 \label{fig:Code zum Aktivieren des Query-Tracers}

 \begin{figure}[H]
 \centering

	\includegraphics[scale=0.7]{snippet.png}
	 \caption{Code zum Aktivieren des Query-Tracers}
 \end{figure}
%\clearpage 


 
 \subsection{Vermischung verschiedener Aufgabenbereiche}
 \label{fig:Vermischung verschiedener Aufgabenbereiche}
Anfang der Speichern-Funktion aus bereits vorhandenen GUI-Klasse. Diese erstreckt sich über mehrere Bildschirmseiten und vermischt Front- und Backend-Logik:
 \begin{figure}[htp]
 \centering

	\includegraphics[scale=0.6]{SeparationOfConcerns.png}
	 \caption{Vermischung verschiedener Aufgabenbereiche}
 \end{figure}
 \clearpage
 
  \subsection{Auszug AbstractTreffer.cs}
 \label{fig:AbstractTreffer.cs}
Mehrere Variablen aus der bereits vorhandenen PrintmedienTreffer-Klasse. Manche sind noch in Benutzung, andere sind obsolet:
 \begin{figure}[htp]
 \centering

	\includegraphics[scale=0.7]{abstractTreffer.png}
	 \caption{AbstractTreffer.cs}
 \end{figure}
 
 \subsection{Klasse DotNetModel}
Objekte der Klasse DotNetModels beinhalten den C\#-Code für jeweils eine zu erzeugende Datei:
 \label{fig:DotNetModel}

 \begin{figure}[H]
 \centering

	\includegraphics[scale=0.55]{dotNetModel.PNG}
	 \caption{Klasse DotNetModel}
 \end{figure}
 \clearpage
 
 \subsection{Insert-Methode}
Ein Beispiel für das automatische Erzeugen einer Query aus der Klasse Query-Generator. Tabellen- und Spaltennamen werden beim Erzeugen eines Query-Generator-Objekts anhand der Klassen- und Property- Bezeichnung der des entsprechenden Table-Models ermittelt:
 \label{fig:Insert-Methode}

 \begin{figure}[H]
 \centering

	\includegraphics[scale=0.7]{insert.PNG}
	 \caption{Insert-Methode}
 \end{figure}
 \clearpage
 
  \subsection{Klasse DotNetModel}
Objekte der Klasse DotNetModels beinhalten den C\#-Code für jeweils eine zu erzeugende Datei:
 \label{fig:DotNetModel}

 \begin{figure}[H]
 \centering

	\includegraphics[scale=0.55]{dotNetModel.PNG}
	 \caption{Klasse DotNetModel}
 \end{figure}
 \clearpage
 

\end{document}